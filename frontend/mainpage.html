<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Ransomware Behavior Analytics</title>

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 30px;
            background: #f5f6fa;
        }
        h1 {
            font-size: 28px;
            margin-bottom: 20px;
        }
        .card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 25px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            background: #373737;
            color: white;
            border-radius: 6px;
            cursor: pointer;
        }
        button:disabled {
            background: #777;
        }
        .chart_results {
            display: flex;
            gap: 20px;
            justify-content: flex-start;
            flex-wrap: wrap;
        }
        .chart_results .chart-container {
            flex: 1 1 300px;       /* ìµœì†Œ 300px, ê³µê°„ ë‚¨ìœ¼ë©´ ëŠ˜ì–´ë‚¨ */
            min-width: 300px;      /* ìµœì†Œ ë„ˆë¹„ */
            height: 350px;         /* ìº”ë²„ìŠ¤ ë†’ì´ ì§€ì • */
            background: #fff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
        }
     
    </style>
</head>
<body>

    <h1>Ransomware Behavior Analytics ğŸ”</h1>

    <!-- sample ì„ íƒ(ë¯¼ê²½) - start -->
    <div class="card">
        <h1>Autoencoder Model ğŸ¤–</h1>
        <h2>Choose for samples of Ransomware Behavior Analytics</h2>
        â­• Multiple selection possibleâ­•
        <div id="checkbox_container" style="max-height: 350px; overflow-y: auto; border: 1px solid #ccc; padding: 10px;">

        </div>
        <button id="trainBtn">ëª¨ë¸ í›ˆë ¨ ì‹œì‘</button>

        <div id="progress_container" style="display:none; margin-top: 20px;">
            <div style="width: 100%; background-color: #e0e0e0; border-radius: 8px;">
                <div id="progress_bar" style="width: 0%; height: 24px; background-color: #4caf50; border-radius: 8px; transition: width 0.4s ease;"></div>
            </div>
            <p id="progress_text" style="text-align: center; margin-top: 5px; font-weight: bold; color: #555;">0%</p>
        </div>

        <p id="status"></p>
    </div>
    <!-- sample ì„ íƒ (ë¯¼ê²½) - end -->


    <!-- Sampleë“¤ì˜ Threshold ê·¸ë˜í”„ í‘œì‹œí•˜ê¸°(ìŠ¹ìš´) -start -->
    <div id="threshold_section" class="card" style="display:none;">
        <h2>ğŸ” Anomaly Threshold Analysis (ì´ìƒ íƒì§€)</h2>
        <p>
            ê° ìƒ˜í”Œì˜ <b style="color:#3498db;">MSE(ì˜¤ì°¨)</b>ê°€ 
            <b style="color:#e67e22;">Threshold(ê¸°ì¤€ì„ )</b>ì„ ì´ˆê³¼í•˜ë©´ 
            ëœì„¬ì›¨ì–´ë¡œ ì˜ì‹¬ë©ë‹ˆë‹¤.<br>
            íŒŒë€ ì ì„ ì´ ì‹¤ì œ ìƒ˜í”Œì˜ ì˜¤ì°¨ì´ë©°, ì£¼í™©ìƒ‰ ì ì„ ì€ ìƒ˜í”Œë³„ ê³„ì‚°ëœ ê¸°ì¤€ì„ ì…ë‹ˆë‹¤.
        </p>
        <div style="height: 400px; width: 100%;">
            <canvas id="threshold_chart" style="height:100%; width:100%;"></canvas>
        </div>
    </div>
    

    <!-- Sampleë“¤ì˜ Threshold ê·¸ë˜í”„ í‘œì‹œí•˜ê¸°(ìŠ¹ìš´) -end -->


    <!-- Autoencoder ê²°ê³¼ -->
 
    <div id="ae_section" class="card" style="display:none;">
    <h2> Autoencoder ê²°ê³¼</h2>
    <div class="chart_row" style="display:flex; gap:20px; width:100%;">
        <div class="chart_col" style="flex:1; min-width:0;">
            <h3>ğŸ“‰ í•™ìŠµ ì†ì‹¤ (Training Loss)</h3>
            <canvas id="ae_loss_chart" style="width:100% !important; height:350px !important;"></canvas>
        </div>
        <div class="chart_col" style="flex:1; min-width:0;">
            <h3>ğŸ“Š Autoencoder Reconstruction Error with Threshold</h3>
            <canvas id="ae_hist_chart" style="width:100% !important; height:350px !important;"></canvas>
        </div>
    </div>
    </div>


    <div id="class_table_section" class="card" style="display:none;">
        <h2>ğŸ“Š í•´ì„ ê²°ê³¼</h2>
        <p>AIê°€ ë¶„ì„í•œ ìƒ˜í”Œë“¤ì˜ <b>Normal vs Anomaly</b> ì˜ˆì¸¡ ê²°ê³¼ì…ë‹ˆë‹¤.</p>

        <div style="overflow-x:auto;">
            <table id="result_table" style="width:100%; border-collapse: collapse; text-align: center;">
                <thead>
                    <tr style="background-color:#f0f0f0;">
                        <th style="border:1px solid #ccc; padding:8px;">Sample</th>
                        <th style="border:1px solid #ccc; padding:8px;">MSE</th>
                        <th style="border:1px solid #ccc; padding:8px;">Threshold</th>
                        <th style="border:1px solid #ccc; padding:8px;">íŒë‹¨</th>
                        <th style="border:1px solid #ccc; padding:8px;">í•´ì„</th>
                        <th style="border:1px solid #ccc; padding:8px;">ì•ŒëŒ</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- JSì—ì„œ í–‰ì„ ì¶”ê°€ -->
                </tbody>
            </table>
        </div>
    </div>



    <!-- class ë¶„ë¥˜ ê·¸ë˜í”„ í‘œì‹œí•˜ê¸°(ìŠ¹í¬) -start  -->

    <div id="class_section" class="card" style="display:none;">
        <h2>ğŸ“Š Class Classification Result (ë¶„ë¥˜ ê²°ê³¼ ìš”ì•½)</h2>
        <p>AIê°€ ë¶„ì„í•œ ê° anomaly ìƒ˜í”Œì˜ <b>10ê°œ ëœì„¬ì›¨ì–´ í´ë˜ìŠ¤ë³„ í™•ë¥ </b>ì„ ì‹œê°í™”í•œ ê·¸ë˜í”„ì…ë‹ˆë‹¤.</p>

        <!-- ê° anomaly ìƒ˜í”Œë³„ ê·¸ë˜í”„ ë‹´ëŠ” ì»¨í…Œì´ë„ˆ -->
        <div class="chart_results" style="display: flex; flex-wrap: wrap; gap: 20px;"></div>
    </div>


    <!-- class ë¶„ë¥˜ ê·¸ë˜í”„ í‘œì‹œí•˜ê¸°(ìŠ¹í¬) -end  -->


    <!-- LSTM ê²°ê³¼ -->
    <div id="lstm_section" class="card" style="display:none;">
        <h2>LSTM ëª¨ë¸ ê²°ê³¼</h2>

        <div class="chart_results"><div class="chart-container">
            <canvas id="lstm_loss"></canvas>
        </div>
        <div class="chart-container">
            <canvas id="lstm_acc"></canvas>
        </div>
        </div>
    </div>


    <!-- Chart.js CDN -->
   
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.1.0/dist/chartjs-plugin-annotation.min.js"></script>

    <script>
        // ===================================================
        // 1) ì„œë²„ì—ì„œ sample_id ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
        // ===================================================
        async function loadSamples() {
            try {
                const res = await fetch("/samples/");
                const data = await res.json();
                const container = document.getElementById("checkbox_container");

                if (data.sample_ids) {
                    data.sample_ids.forEach(id => {
                        const label = document.createElement("label");
                        label.style.display = "block";

                        const checkbox = document.createElement("input");
                        checkbox.type = "checkbox";
                        checkbox.value = id;
                        checkbox.name = "sample_id_checkbox";
                        checkbox.style.marginRight = "5px";

                        label.appendChild(checkbox);
                        label.appendChild(document.createTextNode(id));
                        container.appendChild(label);
                    });
                }
            } catch (e) {
                console.error("ìƒ˜í”Œ ë¡œë“œ ì‹¤íŒ¨:", e);
            }
        }
        loadSamples();


        // ===================================================
        // 2) ëª¨ë¸ í›ˆë ¨ ìŠ¤íŠ¸ë¦¬ë° ìš”ì²­
        // ===================================================
        document.getElementById("trainBtn").onclick = async () => {
            const checkboxes = document.querySelectorAll('#checkbox_container input[type="checkbox"]:checked');

            const selectedValues = Array.from(checkboxes).map(cb => cb.value);

            if (selectedValues.length === 0) {
                alert("í›ˆë ¨í•  ìƒ˜í”Œì„ í•˜ë‚˜ ì´ìƒ ì„ íƒí•´ì£¼ì„¸ìš”.");
                return;
            }

            const btn = document.getElementById("trainBtn");
            const statusText = document.getElementById("status");
            const progressContainer = document.getElementById("progress_container");
            const progressBar = document.getElementById("progress_bar");
            const progressPercent = document.getElementById("progress_text");

            btn.disabled = true;
            statusText.textContent = "ì„œë²„ ì—°ê²° ì¤‘...";
            progressContainer.style.display = "block";
            progressBar.style.width = "0%";
            progressPercent.textContent = "0%";

            document.getElementById("ae_section").style.display = "none";
            document.getElementById("lstm_section").style.display = "none";

            try {
                const response = await fetch("/train/", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ sample_ids: selectedValues })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder("utf-8");

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value, { stream: true });
                    const lines = chunk.split("\n").filter(line => line.trim() !== "");

                    for (const line of lines) {
                        try {
                            const data = JSON.parse(line);

                            if (data.status === "progress") {
                                progressBar.style.width = data.percent + "%";
                                progressPercent.textContent = data.percent + "%";
                                statusText.textContent = data.message;

                            } else if (data.status === "complete") {
                                progressBar.style.width = "100%";
                                progressPercent.textContent = "100%";
                                statusText.textContent = "í›ˆë ¨ ì™„ë£Œ! ê²°ê³¼ ë¶„ì„ ì¤‘...";

                                setTimeout(() => {
                                    renderAutoencoderCharts(data.results.autoencoder);
                                    renderThresholdChart(data.results.predictions);
                                    renderLstmCharts(data.results.lstm);
                                    renderClassTable(data.results.predictions);
                                    renderClassChart(data.results.predictions);

                                    statusText.textContent = "ëª¨ë“  ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.";
                                    btn.disabled = false;
                                }, 500);

                            } else if (data.status === "error") {
                                statusText.textContent = "ì˜¤ë¥˜: " + data.message;
                                progressBar.style.backgroundColor = "red";
                                btn.disabled = false;
                            }

                        } catch (e) {
                            console.error("JSON íŒŒì‹± ì—ëŸ¬:", e);
                        }
                    }
                }

            } catch (err) {
                statusText.textContent = "í†µì‹  ì˜¤ë¥˜ ë°œìƒ: " + err;
                btn.disabled = false;
            }
        };


        // -------------------------------------------------
        // 2. ìƒ˜í”Œë³„ Threshold ì°¨íŠ¸ (Line + Point) - [ìˆ˜ì •ë¨]
        // -------------------------------------------------
        function renderSampleThresholdChart(preds) {
            const labels = preds.map(p => p.sample_id);
            const mses = preds.map(p => p.mse);
            const thresholds = preds.map(p => p.threshold);

            createChart("sample_threshold_chart", {
                type: 'line', // ì„  ê·¸ë˜í”„ë¡œ ë³€ê²½
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Sample MSE (ë‚´ ìƒ˜í”Œ ì˜¤ì°¨)',
                            data: mses,
                            borderColor: '#3498db', // íŒŒë€ìƒ‰ ì„ 
                            backgroundColor: '#3498db',
                            pointRadius: 6,       // ì  í¬ê¸°
                            pointHoverRadius: 8,
                            fill: false,
                            order: 1 // ë ˆì´ì–´ ìˆœì„œ
                        },
                        {
                            label: 'Sample Threshold (ê¸°ì¤€ì„ )',
                            data: thresholds,
                            borderColor: '#e67e22', // ì£¼í™©ìƒ‰ ì„ 
                            backgroundColor: '#e67e22',
                            pointStyle: 'crossRot', // X ëª¨ì–‘ ì 
                            pointRadius: 6,
                            borderDash: [5, 5], // ì ì„  ìŠ¤íƒ€ì¼
                            fill: false,
                            order: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: { display: true, text: 'Per-Sample Threshold vs MSE' },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    },
                    scales: { 
                        y: { 
                            beginAtZero: true,
                            title: { display: true, text: 'MSE / Threshold Value' }
                        } 
                    }
                }
            });
        }




        // ===================================================
        // AUTOENCODER ê·¸ë˜í”„ ì„¹ì…˜
        // ===================================================
        let aeLossChart = null;
        let aeHistChart = null;

        function renderAutoencoderCharts(ae) {
            document.getElementById("ae_section").style.display = "block";

            if (aeLossChart) aeLossChart.destroy();
            if (aeHistChart) aeHistChart.destroy();

            const lossCtx = document.getElementById("ae_loss_chart").getContext("2d");

            // Training Loss Chart
            aeLossChart = new Chart(lossCtx, {
                type: "line",
                data: {
                    labels: ae.loss.map((_, i) => i + 1),
                    datasets: [
                        { label: "Training Loss", data: ae.loss, borderColor: "#3498db", fill: false },
                        { label: "Validation Loss", data: ae.val_loss || [], borderColor: "orange", fill: false }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: { title: { display: true, text: "Autoencoder Loss per Epoch" } }
                }
            });

            // Histogram Chart
            const histCtx = document.getElementById("ae_hist_chart").getContext("2d");
            const counts = ae.histogram.counts;
            const bins = ae.histogram.bins;
            const threshold = ae.global_threshold;



            // â­ bins â†’ centers ë³€í™˜
            let centers = [];
            if (bins.length === counts.length + 1) {
                for (let i = 0; i < counts.length; i++) {
                    centers.push((bins[i] + bins[i + 1]) / 2);
                }
            } else {
                centers = bins.slice();
            }

            // â­ Chart.js threshold ë¼ì¸ plugin
            const thresholdLine = {
                id: 'thresholdLine',
                afterDraw(chart, args, opts) {
                    const { ctx, chartArea: { top, bottom }, scales: { x } } = chart;
                    const xPos = x.getPixelForValue(threshold);

                    ctx.save();
                    ctx.beginPath();
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 4]);
                    ctx.moveTo(xPos, top);
                    ctx.lineTo(xPos, bottom);
                    ctx.stroke();
                    ctx.restore();
                }
            };

            aeHistChart = new Chart(histCtx, {
                type: 'bar',
                data: {
                    datasets: [{
                        label: 'Count',
                        data: counts.map((c, i) => ({ x: centers[i], y: c })),
                        parsing: { xAxisKey: 'x', yAxisKey: 'y' },
                        backgroundColor: 'rgba(46,204,113,0.6)',
                        borderColor: 'rgba(46,204,113,1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            type: 'linear',
                            title: { display: true, text: 'MSE' }
                        },
                        y: {
                            title: { display: true, text: 'Count' }
                        }
                    }
                },
                plugins: [thresholdLine]
            });
        }



        // ===================================================
        // LSTM ê·¸ë˜í”„
        // ===================================================
        let lstmLossChart, lstmAccChart;

        function renderLstmCharts(lstm) {
            document.getElementById("lstm_section").style.display = "block";

            if (lstmLossChart) lstmLossChart.destroy();
            if (lstmAccChart) lstmAccChart.destroy();

            lstmLossChart = new Chart(document.getElementById("lstm_loss"), {
                type: "line",
                data: {
                    labels: lstm.loss.map((_, i) => i + 1),
                    datasets: [
                        { label: "Loss", data: lstm.loss, borderColor: "red", fill: false },
                        { label: "Val Loss", data: lstm.val_loss || [], borderColor: "orange", fill: false }
                    ]
                }
            });

            lstmAccChart = new Chart(document.getElementById("lstm_acc"), {
                type: "line",
                data: {
                    labels: lstm.accuracy.map((_, i) => i + 1),
                    datasets: [
                        { label: "Accuracy", data: lstm.accuracy, borderColor: "blue", fill: false },
                        { label: "Val Accuracy", data: lstm.val_accuracy || [], borderColor: "skyblue", fill: false }
                    ]
                }
            });
        }



        // ===================================================
        // 5) SAMPLE THRESHOLD ê·¸ë˜í”„ + í´ë¦­ ì´ë²¤íŠ¸ â†’ AE Histogram ìˆ˜ì •
        // ===================================================
        let thresholdChart = null;

        function renderThresholdChart(predictions) {
            document.getElementById("threshold_section").style.display = "block";

            const ctx = document.getElementById('threshold_chart').getContext('2d');

            if (thresholdChart) thresholdChart.destroy();

            // ğŸ”¥ ìƒ˜í”Œ ì „ì²´ ì €ì¥ â†’ í´ë¦­ ì‹œ ì°¸ì¡°
            window.samplePredictions = predictions;

            const labels = predictions.map(p => p.sample_id);
            const mses = predictions.map(p => p.mse);
            const thresholds = predictions.map(p => p.threshold);

            thresholdChart = new Chart(ctx, {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Sample MSE",
                            data: mses,
                            borderColor: "#3498db",
                            pointRadius: 6,
                            fill: false
                        },
                        {
                            label: "Threshold",
                            data: thresholds,
                            borderColor: "#e67e22",
                            borderDash: [5, 5],
                            pointRadius: 6,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,   // â­ ê°€ë¡œí­ ë„“ì–´ì§!
                    onClick: function (evt, elements) {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const sample = window.samplePredictions[index];
                            updateAEHistogram(sample);
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: "Sample ID"   // â­ xì¶• ì œëª© ì¶”ê°€
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: "MSE / Threshold"   // â­ yì¶• ì œëª© ì¶”ê°€
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Per-Sample Anomaly Threshold Analysis'
                        }
                    }
                }
            });
        }


        // ===================================================
        // 6) AE Histogram ì—…ë°ì´íŠ¸ (ìƒ˜í”Œ ì„ íƒ ì‹œ)
        // ===================================================
        function updateAEHistogram(sample) {
            if (!aeHistChart) return;

            const bins = sample.histogram.bins;
            const counts = sample.histogram.counts;
            const threshold = sample.threshold;

            aeHistChart.data.labels = bins.map(v => v.toFixed(4));
            aeHistChart.data.datasets = [
                {
                    label: "Reconstruction Error Frequency",
                    data: counts
                }
            ];

            // ğŸ”¥ threshold ë¼ì¸ ì¶”ê°€
            aeHistChart.options.plugins.annotation = {
                annotations: {
                    thresholdLine: {
                        type: "line",
                        scaleID: "x",
                        borderColor: "red",
                        borderWidth: 2,
                        value: threshold,
                        label: {
                            enabled: true,
                            color: "red",
                            content: "Threshold " + threshold.toFixed(4)
                        }
                    }
                }
            };

            aeHistChart.update();
        }



        function interpretCase(mse, th) {
            if (th === 0) return "ê³„ì‚° ë¶ˆê°€";
            const ratio = mse / th;
            if (ratio < 0.5) {
                return "ì •ìƒ (Safe) - ì •ìƒ Encryptor íŒ¨í„´ê³¼ ë§¤ìš° ìœ ì‚¬í•¨";
            } else if (ratio < 0.8) {
                return "ì •ìƒ (Stable) - ì •ìƒ íŒ¨í„´ ëŒ€ë¹„ ë¯¸ì„¸í•œ ë³€ë™ ì¡´ì¬";
            } else if (ratio < 1.0) {
                return "ê²½ê³„ (Warning) - ì •ìƒ ë²”ìœ„ì´ì§€ë§Œ í¸ì°¨ê°€ ë‹¤ì†Œ ìˆìŒ";
            } else if (ratio < 1.5) {
                return "ê²½ë¯¸í•œ ì´ìƒ (Minor Anomaly) - ì •ìƒ íŒ¨í„´ê³¼ ì¼ë¶€ ì°¨ì´ê°€ ê°ì§€ë¨";
            } else if (ratio < 2.0) {
                return "ì´ìƒ (Anomaly) - ì •ìƒ Encryptor í–‰ë™ íŒ¨í„´ê³¼ ëª…í™•í•˜ê²Œ ë‹¤ë¦„";
            } else {
                return "ê³ ìœ„í—˜ (Critical) - baselineì„ í¬ê²Œ ë²—ì–´ë‚œ ê³µê²©ì„± íŒ¨í„´";
            }
        }





        function renderClassTable(predictions) {
            document.getElementById("class_table_section").style.display = "block";

            const tbody = document.querySelector("#result_table tbody");
            tbody.innerHTML = ""; // ê¸°ì¡´ ë‚´ìš© ì´ˆê¸°í™”

            predictions.forEach(sample => {
                const row = document.createElement("tr");

                // Sample ID
                const tdSample = document.createElement("td");
                tdSample.textContent = sample.sample_id;
                row.appendChild(tdSample);

                // MSE
                const tdMSE = document.createElement("td");
                tdMSE.textContent = sample.mse.toFixed(4);
                row.appendChild(tdMSE);

                // Threshold
                const tdThreshold = document.createElement("td");
                tdThreshold.textContent = sample.threshold.toFixed(4);
                row.appendChild(tdThreshold);

                // íŒë‹¨ (MSE > Threshold -> ëœì„¬ì›¨ì–´, ì•„ë‹ˆë©´ ì •ìƒ)
                const tdDecision = document.createElement("td");
                tdDecision.textContent = sample.mse > sample.threshold ? "Anomaly" : "Normal";
                tdDecision.style.color = sample.mse > sample.threshold ? "red" : "green";
                row.appendChild(tdDecision);

                // í•´ì„ (ê°„ë‹¨ ì„¤ëª…)
                const tdInterpret = document.createElement("td");
                const interpretation = interpretCase(sample.mse, sample.threshold)
                tdInterpret.textContent = interpretation;

            
                if(interpretation.includes("ê³ ìœ„í—˜")){
                    tdInterpret.style.color = "red";
                }

                row.appendChild(tdInterpret);


                const tdAlarm = document.createElement("td");
                tdAlarm.style.textAlign = "center";
                tdAlarm.style.width = "50px";

                const alarmCircle = document.createElement("span");
                alarmCircle.style.display = "inline-block";
                alarmCircle.style.width = "16px";
                alarmCircle.style.height = "16px";
                alarmCircle.style.borderRadius = "50%";
                alarmCircle.style.backgroundColor = "gray"; // ê¸°ë³¸ê°’

                // ìƒíƒœë³„ ìƒ‰ìƒ
                if(interpretation.includes("ê³ ìœ„í—˜")){
                    alarmCircle.style.backgroundColor = "red";
                } else if(interpretation.includes("ê²½ê³„") || interpretation.includes("ì´ìƒ")){
                    alarmCircle.style.backgroundColor = "yellow";
                } else {
                    alarmCircle.style.backgroundColor = "green";
                }

                tdAlarm.appendChild(alarmCircle);
                row.appendChild(tdAlarm);


                tbody.appendChild(row);
            });


        }



        // ===================================================
        // CLASSIFICATION BAR CHART
        // ===================================================
        let classChart = null;

        function renderClassChart(predictions) {
            const section = document.getElementById("class_section");
            section.style.display = "block";

            const container = section.querySelector(".chart_results");
            container.innerHTML = ""; // ê¸°ì¡´ ê·¸ë˜í”„ ì´ˆê¸°í™”

            // Anomaly ìƒ˜í”Œë§Œ ì„ íƒ
            const anomalySamples = predictions.filter(s => s.mse > s.threshold);

            const classNames = [
                "Encryptor",
                "Locker",
                "Wiper",
                "Worm-propagating Ransom",
                "Human-operated Ransom",
                "Phishing-based Ransom",
                "RDP Brute-force based",
                "Exploit-based Ransom",
                "USB/Removable-media Ransom",
                "Cloud/SaaS-targeted Ransom"
            ];

            anomalySamples.forEach((sample, idx) => {
                // 1. chart-container ìƒì„±
                const chartDiv = document.createElement("div");
                chartDiv.classList.add("chart-container");
                chartDiv.style.flex = "1";
                chartDiv.style.minWidth = "300px";
                chartDiv.style.height = "400px"; // ë†’ì´ ì§€ì •
                chartDiv.style.marginBottom = "20px";

                // 2. canvas ìƒì„±
                const canvas = document.createElement("canvas");
                canvas.id = `class_chart_${idx}`;
                canvas.style.width = "100%";
                canvas.style.height = "85%";
                chartDiv.appendChild(canvas);


                // 3. True class í…ìŠ¤íŠ¸ ì¶”ê°€
                const trueClassText = document.createElement("div");
                trueClassText.style.textAlign = "center";
                trueClassText.style.marginTop = "5px";
                trueClassText.style.fontWeight = "bold";
                trueClassText.textContent = `True class: ${sample.true_class_name || "ì •ë³´ ì—†ìŒ"}`;
                chartDiv.appendChild(trueClassText);

                container.appendChild(chartDiv);



                // 3. Chart.js ìƒì„±
                const ctx = canvas.getContext('2d');
                new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: classNames,
                        datasets: [{
                            label: `Sample ${sample.sample_id} í´ë˜ìŠ¤ í™•ë¥ `,
                            data: classNames.map(cls => sample.class_probs[cls] ?? 0),
                            backgroundColor: classNames.map((_, i) => `hsl(${i * 36}, 70%, 50%)`)
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false, // ë¶€ëª¨ ë†’ì´ì— ë§ì¶¤
                        plugins: {
                            title: {
                                display: true,
                                text: `ìƒ˜í”Œ ${sample.sample_id} í´ë˜ìŠ¤ í™•ë¥ `
                            },
                            tooltip: { mode: 'index', intersect: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 1,
                                title: { display: true, text: 'í™•ë¥ ' }
                            }
                        }
                    }
                });
            });
        }

    </script>

</body>
</html>
